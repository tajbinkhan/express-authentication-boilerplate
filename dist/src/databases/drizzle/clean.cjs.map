{"version":3,"sources":["../../../../src/databases/drizzle/clean.ts"],"sourcesContent":["import { execSync } from \"child_process\";\nimport \"dotenv/config\";\nimport pg from \"pg\";\n\nclass DatabaseCleaner {\n\tprivate pgPool: pg.Pool;\n\n\tconstructor() {\n\t\tconst pgPoolConfig = { connectionString: process.env.DATABASE_URL };\n\t\tthis.pgPool = new pg.Pool(pgPoolConfig);\n\t}\n\n\t// TODO: Implement this method if you have MongoDB in your project\n\t// private async clearMongoDatabase(): Promise<void> {\n\t// \ttry {\n\t// \t\tawait mongoose.connect(process.env.MONGO_DATABASE_URL || \"\");\n\t// \t\tconst db = mongoose.connection.db;\n\n\t// \t\tif (!db) {\n\t// \t\t\tthrow new Error(\"MongoDB connection is not established\");\n\t// \t\t}\n\n\t// \t\tconst collections = await db.collections();\n\t// \t\tfor (const collection of collections) {\n\t// \t\t\tif (![\"admin\", \"system.profile\"].includes(collection.collectionName)) {\n\t// \t\t\t\tawait collection.drop();\n\t// \t\t\t}\n\t// \t\t}\n\t// \t} catch (error) {\n\t// \t\tconsole.error(\"Error clearing MongoDB:\", error);\n\t// \t} finally {\n\t// \t\tawait mongoose.connection.close(); // Ensure connection closes\n\t// \t}\n\t// }\n\n\tprivate async clearPostgresDatabase(): Promise<void> {\n\t\tconst schemas = [\"public\", \"drizzle\"];\n\n\t\tfor (const schema of schemas) {\n\t\t\ttry {\n\t\t\t\tawait this.pgPool.query(`DROP SCHEMA IF EXISTS ${schema} CASCADE;`);\n\t\t\t\tawait this.pgPool.query(`CREATE SCHEMA ${schema};`);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(`Error handling ${schema} schema:`, error);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate handleConnectionError(error: unknown): void {\n\t\tif (error instanceof Error && \"code\" in error && error.code === \"ECONNREFUSED\") {\n\t\t\tconsole.log(`Connection refused on port ${process.env.PORT}. Ensure PostgreSQL is running.`);\n\t\t\treturn;\n\t\t}\n\t\tconsole.error(\"Error clearing databases or running commands:\", error);\n\t\tprocess.exit(1);\n\t}\n\n\tasync runDbCommands(): Promise<void> {\n\t\ttry {\n\t\t\tawait this.pgPool.connect();\n\t\t\t// await this.clearMongoDatabase();\n\t\t\tawait this.clearPostgresDatabase();\n\n\t\t\tconst commands = [\"db:generate\", \"db:migrate\"];\n\t\t\tcommands.forEach(cmd => execSync(`npm run ${cmd}`, { stdio: \"inherit\" }));\n\n\t\t\tconsole.log(\"Database reset completed successfully\");\n\t\t\tprocess.exit(0);\n\t\t} catch (error) {\n\t\t\tthis.handleConnectionError(error);\n\t\t}\n\t}\n}\n\nconst databaseCleaner = new DatabaseCleaner();\ndatabaseCleaner.runDbCommands().catch(error => {\n\tconsole.error(\"Unhandled error:\", error);\n\tprocess.exit(1);\n});\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,2BAAyB;AACzB,oBAAO;AACP,gBAAe;AAEf,IAAM,kBAAN,MAAsB;AAAA,EACb;AAAA,EAER,cAAc;AACb,UAAM,eAAe,EAAE,kBAAkB,QAAQ,IAAI,aAAa;AAClE,SAAK,SAAS,IAAI,UAAAA,QAAG,KAAK,YAAY;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAyBA,MAAc,wBAAuC;AACpD,UAAM,UAAU,CAAC,UAAU,SAAS;AAEpC,eAAW,UAAU,SAAS;AAC7B,UAAI;AACH,cAAM,KAAK,OAAO,MAAM,yBAAyB,MAAM,WAAW;AAClE,cAAM,KAAK,OAAO,MAAM,iBAAiB,MAAM,GAAG;AAAA,MACnD,SAAS,OAAO;AACf,gBAAQ,MAAM,kBAAkB,MAAM,YAAY,KAAK;AAAA,MACxD;AAAA,IACD;AAAA,EACD;AAAA,EAEQ,sBAAsB,OAAsB;AACnD,QAAI,iBAAiB,SAAS,UAAU,SAAS,MAAM,SAAS,gBAAgB;AAC/E,cAAQ,IAAI,8BAA8B,QAAQ,IAAI,IAAI,iCAAiC;AAC3F;AAAA,IACD;AACA,YAAQ,MAAM,iDAAiD,KAAK;AACpE,YAAQ,KAAK,CAAC;AAAA,EACf;AAAA,EAEA,MAAM,gBAA+B;AACpC,QAAI;AACH,YAAM,KAAK,OAAO,QAAQ;AAE1B,YAAM,KAAK,sBAAsB;AAEjC,YAAM,WAAW,CAAC,eAAe,YAAY;AAC7C,eAAS,QAAQ,aAAO,+BAAS,WAAW,GAAG,IAAI,EAAE,OAAO,UAAU,CAAC,CAAC;AAExE,cAAQ,IAAI,uCAAuC;AACnD,cAAQ,KAAK,CAAC;AAAA,IACf,SAAS,OAAO;AACf,WAAK,sBAAsB,KAAK;AAAA,IACjC;AAAA,EACD;AACD;AAEA,IAAM,kBAAkB,IAAI,gBAAgB;AAC5C,gBAAgB,cAAc,EAAE,MAAM,WAAS;AAC9C,UAAQ,MAAM,oBAAoB,KAAK;AACvC,UAAQ,KAAK,CAAC;AACf,CAAC;","names":["pg"]}